## JWT Verification Using OPA

### JWT structure
A JWT has three parts (Base64-encoded and separated by dots)
```css
HEADER.PAYLOAD.SIGNATURE
```

```JSON
HEADER

{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "z1lO6wP50tT0P5jF1868U"
}
```

```json
PAYLOAD

// Example 1
{
  "https://grainger.com/cust/profileId": "722e7b17-bc1d-4e3a-a204-a1e025895354",
  "https://grainger.com/cust/ver": "1.0",
  "https://grainger.com/cust/currentAccount": "0812345678",
  "iss": "https://logindev.grainger.com",
  "sub": "auth0|66351f01cf570379c2191288",
  "aud": [
    "https://www.grainger.com"
  ],
  "iat": 1745907854,
  "exp": 1745908754,
  "scope": "openid profile email offline_access",
  "azp": "UuVN0EPTxocUoSg3OD8xc8ifKHL8oSWJ",
  "act": {
    "sub": "delegate@example.com",
  }
}

//Example 2
{
  "sub": "user-123",
  "role": "admin",
  "account_id": "acct-777",
  "exp": 1761350400,
  "iss": "https://auth.example.com/"
}

```

```json
SIGNATURE

Generated by signing the base64url(header + "." + payload) using the issuer’s private key corresponding to that kid.
```

Purpose of kid:
- A JWT issuer (like Auth0, Okta, or your internal IdP) usually has multiple signing keys active at once.
- Each public key in its JWKS (JSON Web Key Set) has a unique kid (Key ID).

When verifier (OPA or Kotlin service) receives a JWT:

- It decodes the header.
- Reads "kid": "z1lO6wP50tT0P5jF1868U".
- Looks up the JWKS endpoint (e.g. https://auth.example.com/.well-known/jwks.json).
- Finds the public key with that same kid.
- Uses that key to verify the RS256 signature.

```json

JWKS (JSON Web Key Set)

{
  "keys": [
    {
      "kid": "abcd1234",
      "kty": "RSA",
      "alg": "RS256",
      "n": "...",
      "e": "AQAB"
    },
    ...
  ]
}

1️⃣ "n" — the modulus

    - This is the giant integer used in RSA math — the product of two large prime numbers (p and q).

    - It’s what makes the key unique and strong.

    - The value is base64url-encoded; decoding it gives you a 2048-bit or 4096-bit integer.

In cryptographic notation, 

the public key is: Public key = (n, e)

the private key (held by the Identity Provider) is: Private key = (n, d) where where d is the private exponent derived from p, q, and e.

2️⃣ "e": "AQAB"

This is the public exponent.

"AQAB" is base64url for the bytes 0x01 0x00 0x01, which equals 65537.

65537 is the standard public exponent used in nearly all RSA keys because it’s secure and efficient.

```
#### Usage
When verifying a JWT signed with RS256:

- The JWT header tells "alg": "RS256" and "kid": "abcd1234".
- Fetch the JWKS (set of public keys) from the issuer
- Pick the key where kid matches.
- The verifier library uses n and e to reconstruct the RSA public key object.
- It verifies the JWT’s signature by applying RSA verification math using (n, e).

If the math works out — meaning the signature is consistent with the payload and header — you know:
- the token was signed by the holder of the corresponding private key (your IdP),
- and the token wasn’t tampered with.

```kotlin
val jwkJson = """{
  "kty": "RSA",
  "n": "yFxBe5RbrSwnQgcHns9QXV911H7YF6oDv03plKkJs1MEUb80pFHLlwetcOnDpgqjcCE2hUmr_P6uBnStuC5LBye2_C7LcqGRIM-1DyDz8MmbMcSlWS1dVd08MMQ0xP_JX0-bVkmK9mrtaHKZoxKk3_d-9LarkllKo1FAIySRE1UAPlI6MJcsqgU_Y_xCuBOGYXJDZeltIGFsc6OlmHCHeYf1mxpUERjg4XeKLku3hg9WMLmuYwsPY4238CovM28aFphCfSAqiGwBHgc10V4zqxJM7KW7MXiUqSc0bUrrpQmtGtWjXuK2b3Nzwg6pR60xTPcWkCqHN61Rz1Oei8dF2Q",
  "e": "AQAB"
}"""

val jwk = RSAKey.parse(jwkJson)  // Nimbus will create an RSAKey object from 'n' and 'e'

val publicKey = jwk.toRSAPublicKey()  // Standard java.security.interfaces.RSAPublicKey

// The publicKey now contains modulus (n) and exponent (e)
// You can use this to verify RS256 signatures.

```


## Approach 1

```mermaid
flowchart TD
    subgraph Client["Client"]
        A["HTTP request with JWT"]
    end

    subgraph Service["Microservice"]
        A --> B["JwtVerifier verifies JWT with JWKS"]
        B --> C["Extract userId, role, accountId"]
        C --> D["Load cart metadata"]
        D --> E["Call OpaClient to request authorization"]
    end

    subgraph OPA["OPA Sidecar"]
        E --> F["Rego policy evaluation"]
        F --> G["Check token not expired, role allowed, ownership rules"]
        G --> H["Return decision (allow or deny)"]
    end

    H --> I["Service enforcement layer"]
    I --> J["Business logic executes if allowed"]



```


- Spring boot service
    - Extracts the JWT from Authorization: Bearer ...
    - Verifies the RS256 signature using JWKS (kid-based key lookup)
    - Enforces issuer / audience / expiry
    - Builds a strongly-typed auth context
    - Calls OPA with that context
- Proposed technology:
    - Nimbus JOSE + JWT (battle-tested in prod on JVM)
    - An AuthFilter (or WebFilter in WebFlux / OncePerRequestFilter in MVC)
    - A tiny OPA client

#### JWTVerifier
- Cache the JWKS (public keys) from your Identity Provider
- Verify RS256 signature using the correct kid
- Validate iss, aud, and exp
- Return a trusted AuthContext you can pass to OPA
- Why this is production-ready
    - Validates issuer + audience (prevents token meant for service A being replayed to service B).
    - Checks expiry.
    - Uses JWKS + kid so you don’t hardcode public keys.
    - Throws explicit Unauthorized instead of letting random NullPointerExceptions bubble out.

```kotlin

import com.nimbusds.jose.JWSAlgorithm
import com.nimbusds.jose.proc.SecurityContext
import com.nimbusds.jose.jwk.source.JWKSource
import com.nimbusds.jose.jwk.source.RemoteJWKSet
import com.nimbusds.jose.proc.JWSVerificationKeySelector
import com.nimbusds.jose.util.DefaultResourceRetriever
import com.nimbusds.jwt.JWTClaimsSet
import com.nimbusds.jwt.proc.DefaultJWTProcessor
import java.net.URL
import java.time.Instant

data class AuthContext(
    val userId: String,      // from sub
    val accountId: String,   // custom claim
    val role: String,        // "standard", "admin", etc.
    val expEpochSeconds: Long,
    val rawClaims: JWTClaimsSet
)

class JwtVerifier(
    jwksUrl: String,
    private val expectedIssuer: String,
    private val expectedAudience: String
) {

    // Tune timeouts so a slow IdP doesn't hang your service
    private val resourceRetriever = DefaultResourceRetriever(
        /* connectTimeoutMs = */ 2000,
        /* readTimeoutMs    = */ 2000
    )

    // RemoteJWKSet automatically:
    // - pulls JWKS from your IdP
    // - caches it in-memory
    // - uses 'kid' to pick the right key
    private val jwkSource: JWKSource<SecurityContext> =
        RemoteJWKSet(URL(jwksUrl), resourceRetriever)

    // The JWT processor:
    // - figures out the key from 'kid'
    // - verifies RS256 signature
    private val jwtProcessor = DefaultJWTProcessor<SecurityContext>().apply {
        jwsKeySelector = JWSVerificationKeySelector(
            JWSAlgorithm.RS256,
            jwkSource
        )
    }

    fun verifyAndExtract(bearerToken: String): AuthContext {
        val token = bearerToken.removePrefix("Bearer ").trim()

        // 1. Cryptographic verification (signature + header.alg match)
        val claims: JWTClaimsSet = jwtProcessor.process(token, null)

        // 2. Validate issuer
        if (claims.issuer != expectedIssuer) {
            throw AuthException.Unauthorized("Invalid issuer: ${claims.issuer}")
        }

        // 3. Validate audience
        if (!claims.audience.contains(expectedAudience)) {
            throw AuthException.Unauthorized("Invalid audience: ${claims.audience}")
        }

        // 4. Validate expiration (defense-in-depth; Nimbus also enforces timestamps
        // if you configure a DefaultJWTClaimsVerifier, but we double check)
        val expInstant: Instant = claims.expirationTime?.toInstant()
            ?: throw AuthException.Unauthorized("Missing exp")
        if (Instant.now().isAfter(expInstant)) {
            throw AuthException.Unauthorized("Token expired at $expInstant")
        }

        // 5. Pull app-specific claims
        val userId = claims.subject
            ?: throw AuthException.Unauthorized("Missing sub")
        val accountId = claims.getStringClaim("account_id")
            ?: throw AuthException.Unauthorized("Missing account_id")
        val role = claims.getStringClaim("role")
            ?: throw AuthException.Unauthorized("Missing role")

        return AuthContext(
            userId = userId,
            accountId = accountId,
            role = role,
            expEpochSeconds = expInstant.epochSecond,
            rawClaims = claims
        )
    }
}

sealed class AuthException(msg: String) : RuntimeException(msg) {
    class Unauthorized(msg: String) : AuthException(msg)
}

```
### We typically construct JwtVerifier once at stratup, e.g.:
```kotlin

val jwtVerifier = JwtVerifier(
    jwksUrl = "https://auth.example.com/.well-known/jwks.json",
    expectedIssuer = "https://auth.example.com/",
    expectedAudience = "cart-api"
)

```
#### Step A: Put the settings in application.yml
```yaml
security:
  jwks-url: "https://auth.example.com/.well-known/jwks.json"
  issuer: "https://auth.example.com/"
  audience: "cart-api"

```

#### Step B: Create a @Configuration class to build the bean

```kotlin

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.beans.factory.annotation.Value

@Configuration
class SecurityConfig {

    @Bean
    fun jwtVerifier(
        @Value("\${security.jwks-url}") jwksUrl: String,
        @Value("\${security.issuer}") expectedIssuer: String,
        @Value("\${security.audience}") expectedAudience: String
    ): JwtVerifier {
        return JwtVerifier(
            jwksUrl = jwksUrl,
            expectedIssuer = expectedIssuer,
            expectedAudience = expectedAudience
        )
    }
}

```
#### Step C: Inject and use it

Example in a WebFlux WebFilter or an MVC OncePerRequestFilter or even directly in a controller/service:

```kotlin

import org.springframework.stereotype.Component
import jakarta.servlet.Filter
import jakarta.servlet.FilterChain
import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpServletResponse
import jakarta.servlet.ServletRequest
import jakarta.servlet.ServletResponse

@Component
class AuthFilter(
    private val jwtVerifier: JwtVerifier,
    private val opaClient: OpaClient // you'd also @Bean this the same way
) : Filter {

    override fun doFilter(
        request: ServletRequest,
        response: ServletResponse,
        chain: FilterChain
    ) {
        val httpReq = request as HttpServletRequest
        val httpResp = response as HttpServletResponse

        val authHeader = httpReq.getHeader("Authorization")
        if (authHeader.isNullOrBlank()) {
            httpResp.status = 401
            httpResp.writer.write("Missing Authorization header")
            return
        }

        // <-- This is where we use the singleton JwtVerifier built at startup
        val subjectCtx = try {
            jwtVerifier.verifyAndExtract(authHeader)
        } catch (ex: AuthException.Unauthorized) {
            httpResp.status = 401
            httpResp.writer.write("Unauthorized: ${ex.message}")
            return
        }

        // You could stash subjectCtx in request attributes / SecurityContext
        httpReq.setAttribute("authContext", subjectCtx)

        chain.doFilter(httpReq, httpResp)
    }
}
// jwtVerifier here is injected — not re-created.
```
### OPA Client (sidecar call)
**Service ask OPA "can this caller do X on this cart"**

Sample request to OPA

```json
POST /v1/data/cart_authz/decision
{
  "input": {
    "action": "update_cart",
    "resource": {
      "cartId": "CART-12345",
      "cartOwnerUserId": "user-555",
      "cartAccountId": "acct-777"
    },
    "subject": {
      "userId": "user-999",
      "accountId": "acct-777",
      "role": "admin",
      "jwt": {
        "exp": 1761350400
      }
    }
  }
}
```

OPA response

```json
{
  "result": { "allow": true, "reason": "authorized" }
}
```


```kotlin

import java.net.http.HttpClient
import java.net.http.HttpRequest
import java.net.http.HttpResponse
import java.net.URI
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue

data class OpaDecision(val allow: Boolean, val reason: String)

class OpaClient(
    private val opaBaseUrl: String = "http://localhost:8181", // sidecar
) {
    private val client = HttpClient.newHttpClient()
    private val mapper = jacksonObjectMapper()

    fun authorize(
        action: String,
        cart: CartContext,
        subject: AuthContext
    ): OpaDecision {
        // Build the input OPA expects
        val payload = mapOf(
            "input" to mapOf(
                "action" to action,
                "resource" to mapOf(
                    "cartId"           to cart.cartId,
                    "cartOwnerUserId"  to cart.cartOwnerUserId,
                    "cartAccountId"    to cart.cartAccountId
                ),
                "subject" to mapOf(
                    "userId"      to subject.userId,
                    "accountId"   to subject.accountId,
                    "role"        to subject.role,
                    "jwt"         to mapOf(
                        "exp" to subject.expEpochSeconds
                    )
                )
            )
        )

        val bodyJson = mapper.writeValueAsString(payload)

        val req = HttpRequest.newBuilder()
            .uri(URI.create("$opaBaseUrl/v1/data/cart_authz/decision"))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(bodyJson))
            .build()

        val resp = client.send(req, HttpResponse.BodyHandlers.ofString())

        if (resp.statusCode() !in 200..299) {
            throw RuntimeException("OPA error ${resp.statusCode()}: ${resp.body()}")
        }

        // OPA responds like:
        // { "result": { "allow": true, "reason": "authorized" } }
        val parsed: Map<String, Any?> = mapper.readValue(resp.body())
        val result = parsed["result"] as Map<*, *>

        return OpaDecision(
            allow  = result["allow"] as Boolean,
            reason = result["reason"] as String
        )
    }
}

data class CartContext(
    val cartId: String,
    val cartOwnerUserId: String,
    val cartAccountId: String
)

```
Prod notes:

- We’re using localhost:8181 because OPA is running as a sidecar in the same pod.
- We fail closed: if OPA is unreachable or returns non-2xx, we throw → you return 403.

### Rego policy (cart_authz/decision)
```rego

package cart_authz

default decision = {"allow": false, "reason": "denied_by_default"}

decision = {
  "allow": true,
  "reason": "authorized"
} {
  not token_expired
  action_allowed
  scope_allowed
}

# reject token if it's past exp
token_expired {
  now := time.now_ns() / 1000000000
  exp := input.subject.jwt.exp
  exp < now
}

valid_actions := {"create_cart", "view_cart", "update_cart"}

action_allowed {
  valid_actions[input.action]
  role_ok
}

role_ok {
  input.subject.role == "standard"
}
role_ok {
  input.subject.role == "admin"
}

# standard user: can only touch own cart in own account
scope_allowed {
  input.resource.cartOwnerUserId == input.subject.userId
  input.resource.cartAccountId   == input.subject.accountId
}

# admin: can touch any cart in same account
scope_allowed {
  input.subject.role == "admin"
  input.resource.cartAccountId == input.subject.accountId
}

```

### Wiring all together in a controller / handler

```kotlin
fun handleUpdateCart(
    authHeader: String,
    cartId: String,
    requestBody: UpdateCartRequest
): HttpResponseData {

    // 1. Verify JWT and extract trusted claims
    val subjectCtx: AuthContext = jwtVerifier.verifyAndExtract(authHeader)

    // 2. Load cart record from *your* data source
    //    You already have to do this before you mutate the cart anyway.
    val cartRecord = cartRepository.findById(cartId)
        ?: return forbidden("Cart not found")

    val cartCtx = CartContext(
        cartId = cartRecord.id,
        cartOwnerUserId = cartRecord.ownerUserId,
        cartAccountId = cartRecord.accountId
    )

    // 3. Ask OPA for authorization
    val decision = opaClient.authorize(
        action = "update_cart",
        cart = cartCtx,
        subject = subjectCtx
    )

    if (!decision.allow) {
        return forbidden("Forbidden: ${decision.reason}")
    }

    // 4. Authorized → perform business logic
    cartService.updateCart(cartRecord, requestBody)

    return ok("Cart updated")
}

private fun forbidden(msg: String): HttpResponseData =
    HttpResponseData(status = 403, body = msg)

private fun ok(msg: String): HttpResponseData =
    HttpResponseData(status = 200, body = msg)

data class HttpResponseData(val status: Int, val body: String)

```
## Why this works in production

#### Defense in depth

- You don’t trust claims until you verify signature, issuer, audience, and exp with JWKS.
- You don’t trust authorization until OPA approves.

#### Auditable

- Rego files are versioned. Security/compliance can review cart_authz.rego like code.

#### Least privilege

- Standard user can only update their own cart.
- Admin can only operate within same account/tenant, not globally.

#### Fast

- OPA is localhost.
- JWKS is cached by Nimbus; you’re not downloading keys per request.
- Hit DB once (to load the cart you were going to update anyway).


## Approach 2

**“OPA as the single policy brain,” where OPA:**

- Verifies the JWT signature (authN)
- Fetches the cart info to figure out ownership (resource context
- Decides allow/deny (authZ)

```mermaid

flowchart TD
    %% =========================
    %% CLIENT LAYER
    %% =========================
    subgraph Client["Client (Caller)"]
        REQ["HTTP request with Authorization: Bearer <JWT>"]
    end

    %% =========================
    %% SERVICE LAYER
    %% =========================
    subgraph ServicePod["Your Microservice"]
        NOTEPEP["PEP: Policy Enforcement Point"]
        REQ --> SENDOPA["Send auth check to OPA sidecar
        input = { jwt, action, cartId }"]
        SENDOPA --> WAIT["Wait for OPA decision"]
    end

    %% =========================
    %% OPA LAYER
    %% =========================
    subgraph OPASidecar["OPA Sidecar"]
        NOTEOPA["Central auth logic"]
        direction TB

        SENDOPA --> VERIFYJWT["Step 1: Verify JWT"]
        VERIFYJWTDETAILS["- Read kid from header
        - Fetch JWKS public key
        - Verify RS256 signature
        - Validate iss / aud / exp
        - Extract userId / role / accountId"]

        VERIFYJWT --> VERIFYJWTDETAILS --> FETCHCART["Step 2: Fetch cart metadata"]

        FETCHCARTDETAILS["- Call cart service
        - Get cartOwnerUserId
        - Get cartAccountId"]

        FETCHCART --> FETCHCARTDETAILS --> AUTHZ["Step 3: Run Rego policy"]

        AUTHZDETAILS["- standard role: only own cart
        - admin role: any cart in same account
        - default deny"]

        AUTHZ --> AUTHZDETAILS --> DECISION["OPA returns:
        allow or deny + reason"]
    end

    %% =========================
    %% ENFORCEMENT + BUSINESS LOGIC
    %% =========================
    DECISION --> ENFORCE["Service enforces decision
    (403 if deny)"]
    ENFORCE --> BUSINESS["Business logic runs
    (update cart, publish events, etc.)"]



```
This is a different architecture than the previous one. It’s more centralized logic, but it’s also trickier to implement.

#### Considerations:

- High-level request flow
- OPA policy (Rego) that:
    - validates RS256 JWT using JWKS
    - calls Cart API to get cart info
    - enforces admin vs standard rules
- What the micro-service sends to OPA
- Production concerns needed to be handled
- Assumptions
    - OPA can reach:
        - JWKS endpoint from your IdP (public or internal auth server)
        - cart service API (internal cluster service)
        - The token uses RS256 and includes sub, account_id, role, exp.
        - Cart API returns cart JSON including ownerUserId and accountId.

#### Request execution flow

- **Client calls**
```json
PATCH /v2/carts/CART-12345
with header:
Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6...
```

- **Service** - does NOT verify JWT and does NOT look up the cart.
Instead, it just builds an authorization check request to OPA:
    - Sends raw JWT
    - Sends action (“update_cart”)
    - Sends which cart is being touched (“CART-12345”)
```
POST to OPA:
http://localhost:8181/v1/data/cart_authz/decision
```
**Body**
```json
{
  "input": {
    "jwt": "eyJhbGciOiJSUzI1NiIsImtpZCI6InoxbE...<snip>",
    "action": "update_cart",
    "cartId": "CART-12345"
  }
}
```

- **Inside OPA**

    - Decode JWT header, read kid, fetch the JWKS, pick the right public key, verify RS256 signature.
    - Parse claims: sub, role, account_id, exp, etc.
    - Call Cart API to fetch cart metadata: ownerUserId, accountId.
    - Apply policy:
        - standard ⇒ can only act on own cart in same account
        - admin ⇒ can act on any cart in same account

- **OPA responds**
```json
{
  "result": {
    "allow": true,
    "reason": "authorized"
  }
}
```
- **Service enforces that if allow = false responds with 403**. OPA became the **PDP (Policy Decision Point)** and partially the **PIP (Policy Information Point)**. Service is just the **PEP (Policy Enforcement Point)**.

- **Rego Policy**
    - Verify JWT signature & expiry
    - Fetch JWKS
    - Fetch cart data from cart service
    - Enforce role/account scoping

**cart_authz.rego**

```rego
package cart_authz

default decision = {"allow": false, "reason": "denied_by_default"}

/*
  Entry point.
*/
decision = {"allow": true, "reason": "authorized"} {
  # 1. Verify JWT signature, pull claims
  verified_claims := verify_jwt(input.jwt)

  # 2. Check expiration inside verified claims
  not token_expired(verified_claims)

  # 3. Check requested action is valid
  valid_action(input.action)

  # 4. Fetch cart details from cart service
  cart := get_cart(input.cartId)

  # 5. Authorization logic (role + ownership + account)
  scope_allowed(verified_claims, cart)
}

/*
  Check token is not expired.
  'exp' is numeric seconds-since-epoch.
*/
token_expired(claims) {
  now := time.now_ns() / 1000000000
  claims.exp < now
}

/*
  Which actions do we regulate?
*/
valid_action(action) {
  some a
  allowed := {"create_cart", "view_cart", "update_cart"}
  a := allowed[_]
  a == action
}

/*
  scope_allowed enforces:
    - standard: user can only touch their own cart in their own account
    - admin   : can touch any cart in same account
*/
scope_allowed(claims, cart) {
  # Standard path
  claims.role == "standard"
  cart.ownerUserId == claims.sub
  cart.accountId == claims.account_id
}

scope_allowed(claims, cart) {
  # Admin path
  claims.role == "admin"
  cart.accountId == claims.account_id
}

########################################
# JWT VERIFICATION
########################################

# verify_jwt takes the raw JWT string and returns verified claims
verify_jwt(token) = claims {
  # Decode without trust first, so we can read header.kid and alg.
  [header, payload, signature] := io.jwt.decode_segments(token)

  # Enforce expected alg
  header.alg == "RS256"

  # Resolve signing key from JWKS using kid
  jwk := select_jwk(header.kid)

  # Validate the signature using the JWK we chose
  io.jwt.verify_rs256(token, jwk)

  # Parse claims from payload (payload is base64url decoded JSON already)
  claims = payload

  # Optional hardening: issuer and audience checks
  claims.iss == "https://auth.example.com/"
  claims.aud[_] == "cart-api"
}

# select_jwk downloads the JWKS and returns the key with matching kid
select_jwk(kid) = jwk {
  jwks := fetch_jwks()
  some k
  k := jwks.keys[_]
  k.kid == kid
  jwk = k
}

# Fetch JWKS from IdP.
# In production you'd point this at your IdP's /.well-known/jwks.json.
fetch_jwks() = jwks {
  resp := http.send({
    "method": "GET",
    "url": "https://auth.example.com/.well-known/jwks.json",
    "timeouts": {
      "connect": "2s",
      "read": "2s"
    }
  })

  resp.status_code == 200
  jwks := resp.body
}

########################################
# RESOURCE LOOKUP
########################################

# get_cart calls your internal cart service to get owner + account.
# Assumes that endpoint returns JSON like:
# {
#   "cartId": "CART-12345",
#   "ownerUserId": "user-555",
#   "accountId": "acct-777"
# }
#
# Good practice:
# - This should be a lightweight "metadata" endpoint, not the full cart with prices etc.
# - It must be internal-only and secured (OPA sidecar must be allowed, others not).
#
get_cart(cartId) = cart {
  cart_svc_resp := http.send({
    "method": "GET",
    "url": sprintf("http://cart-service.cart-namespace.svc.cluster.local/internal/cart-meta/%s", [cartId]),
    "timeouts": {
      "connect": "1s",
      "read": "1s"
    },
    "headers": {
      # Optional: mTLS or internal service auth header, so only OPA can call.
      # "x-internal-auth": "opa-sidecar"
    }
  })

  cart_svc_resp.status_code == 200
  cart := cart_svc_resp.body
}

```

- **Explanantion of the Rego Policy**
    - io.jwt.decode_segments() and io.jwt.verify_rs256():
        - decode_segments() is used to parse the token without trusting it yet, so we can read kid.
        - verify_rs256() actually checks the signature against the selected JWK.
    - Verify:
        - alg is RS256 (no “alg: none” downgrade)
        - issuer (iss) matches what we expect
        - audience (aud) contains our service name
        - expiration (exp) not passed
    - Performing tenant isolation in scope_allowed.

    ⚠ Critical: http.send is used twice:
    - to get JWKS
    - to get cart owner

That means OPA is now doing network I/O during each decision.

Also, note the cart endpoint we’re calling:
http://customer-order-cart-api-dev-base-vd-dev.customer-order-cart-payment-team-config.mesh.internal:9091/cart-meta/{cartId}
That’s a typical cluster-internal DNS name in Kubernetes. **You’d expose a fast internal “metadata” endpoint for this purpose that returns only what OPA needs (not full cart lines, promos, etc.)**. 

#### Production concerns

**4.1 Latency & availability**

- OPA is now doing network calls (JWKS + cart service) per decision.
- If cart service is slow, authz blocks your request path.
- If JWKS endpoint is slow or down, token cannot be verified → all calls fail.
- We’ve now coupled authorization availability to both identity provider and downstream microservice availability.

**Mitigations**:

- JWKS caching:
    - We can add policy-side caching by putting the JWKS into data via bundles instead of calling http.send to JWKS every time.
    - In real deployments, typically pre-mount the JWKS keys into OPA as data.jwks or ship them via OPA bundles that refresh periodically.

- Cart metadata caching:
    - We can introduce a lightweight “cart metadata cache” service that’s extremely fast and replicated, or even share a local sidecar cache.
    - Or: re-think and move cart ownership lookup back into the app (which is why most teams eventually go back to the other model).

**4.2 Security of the internal cart-meta endpoint**

- We do NOT want random pods calling /internal/cart-meta/{cartId} and enumerating who owns what. **[This might not be our concern since OPA will run as a side car in alongside app container]**
So we protect it:
    - mTLS between OPA sidecar and cart service
    - or a shared internal secret header like x-internal-auth: opa-sidecar that is only injected into OPA pod and validated by cart service
    - or network policies in Kubernetes (allow traffic only from same pod / namespace)
    - Bottom line: lock that endpoint down.

**4.3 Blast radius**

In this approach, any bug in Rego (like skipping scope_allowed) instantly becomes a security bug for every request. There's no “two-layer” safety net (app then OPA). You have central brain = more power = more risk.

You must treat the Rego as production code:
- version control
- review/approval
- automated tests (OPA supports opa test)
- canary rollout (push new policy to one replica first)

**4.4 Timeouts / fail closed**

In production you should fail closed:

- If http.send to cart-meta returns 404 or 500 or times out → allow=false with reason "cart_unavailable" or similar.
- If JWKS fetch fails → allow=false with "jwks_unavailable".
Otherwise attackers can exploit fallback logic.

Here’s a safer version of get_cart that fails closed:

```kotlin
get_cart(cartId) = cart {
  cart_svc_resp := http.send({
    "method": "GET",
    "url": sprintf("http://customer-order-cart-api-dev-base-vd-dev.customer-order-cart-payment-team-config.mesh.internal:9091/cart-meta/%s", [cartId]),
    "timeouts": {"connect": "1s", "read": "1s"},
    "headers": {
      "x-internal-auth": "opa-sidecar"
    }
  })

  cart_svc_resp.status_code == 200
  cart := cart_svc_resp.body
}

# if status != 200, rule above fails, so decision cannot succeed, so allow=false.

```

#### Where this model fits better

This “OPA does everything” model is usually used when:
- We want authN + authZ logic owned by a central security/policy team, not app teams.
- We want one canonical place to evaluate “can user X do Y to resource Z”.
- We’re okay accepting that OPA sidecar is now a hard dependency at runtime.
- We’re running fairly tight cluster networking so OPA can securely call internal services.

It is powerful. It’s also higher operational risk (availability coupling, latency, cache staleness, etc.).